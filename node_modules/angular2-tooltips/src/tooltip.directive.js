var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Input, Directive, ElementRef, ViewContainerRef, ComponentFactoryResolver, Inject } from "@angular/core";
import { TooltipComponent } from "./tooltip.component";
import { DOCUMENT } from "@angular/platform-browser";
/**
 * Displays a tooltip over the element that contains this directive when
 * the active input is true.
 * @example:
 * <p>
 *    Only one word in this sentence will have a
 *    <span tooltip="hello" [active]="true">tooltip</span>.
 * </p>
 */
var TooltipDirective = (function () {
    function TooltipDirective(_resolver, _container, _el, _document) {
        this._resolver = _resolver;
        this._container = _container;
        this._el = _el;
        this._document = _document;
        this.parentSelector = "body"; // where the tooltip gets added
    }
    /**
     * Add the tooltip component on init.
     */
    TooltipDirective.prototype.ngOnInit = function () { this.addTooltip(); };
    /**
     * Destroy the tooltip component on destroy.
     */
    TooltipDirective.prototype.ngOnDestroy = function () { if (this._tooltipRef) {
        this._tooltipRef.destroy();
    } };
    /**
     * Listens for active state changes and shows / hides the tooltip
     * based on the value.
     */
    TooltipDirective.prototype.ngOnChanges = function (changes) {
        if (changes["active"] && typeof this.active !== "undefined") {
            if (changes["active"]["currentValue"]) {
                this.showTooltip();
            }
            else {
                this.hideTooltip();
            }
        }
    };
    /**
     * Show the tooltip on hover, if it is not being manually shown / hidden
     * by the active attribute.
     */
    TooltipDirective.prototype.onMouseOver = function (ev) {
        if (typeof this.active === "undefined") {
            this.showTooltip();
        }
    };
    /**
     * Hide the tooltip on leave, if it is not being manually shown / hidden
     * by the active attribute.
     */
    TooltipDirective.prototype.onMouseLeave = function (ev) {
        if (typeof this.active === "undefined") {
            this.hideTooltip();
        }
    };
    /**
     * Waits until a value has a constant value and resolves the promise.
     * Current usage is to make sure an element is finished rendering and is in
     * place before performing an action.
     * @param valFunc - a function that returns the value to wait for
     * @param threshold - the number of consecutive times the value must be
     *    consistent before being deemed final.
     * @param timeout - maximum amount of time (ms) to continue checking for a
     *    consistent value
     */
    TooltipDirective.prototype.waitForFinalValue = function (valFunc, options) {
        if (options === void 0) { options = {}; }
        // override default options
        var ops = Object.assign({
            threshold: 5,
            intervalTime: 100,
            timeout: 5000
        }, options);
        // return the promise
        return new Promise(function (resolve, reject) {
            var value = valFunc();
            var totalTime = 0; // track total time
            var checks = 0; // track the number of consecutive checks
            var interval = setInterval(function () {
                if (checks > ops.threshold) {
                    clearInterval(interval);
                    resolve(value);
                }
                else if (totalTime > ops.timeout) {
                    clearInterval(interval);
                    reject("Timed out when waiting for a final value.");
                }
                totalTime += ops.intervalTime;
                if (value === valFunc()) {
                    checks++;
                }
                else {
                    // value changed, reset.
                    value = valFunc();
                    checks = 0;
                }
            }, ops.intervalTime);
        });
    };
    /**
     * Dynamically adds a tooltip component
     */
    TooltipDirective.prototype.addTooltip = function () {
        var _this = this;
        // resolve the promise if the tooltip already exists
        if (this._tooltipRef) {
            return Promise.resolve(this._tooltipRef);
        }
        // add the tooltip when the element is in place
        return this.waitForFinalValue(function () { return _this._el.nativeElement.offsetTop; })
            .then(function () {
            // get the factory for creating tooltips
            var tooltipFactory = _this._resolver.resolveComponentFactory(TooltipComponent);
            // create the tooltip
            _this._tooltipRef = _this._container.createComponent(tooltipFactory);
            // append the component to the document body
            _this._document.querySelector(_this.parentSelector)
                .appendChild(_this._tooltipRef.location.nativeElement);
            return _this._tooltipRef;
        });
    };
    /**
     * Adds the tooltip (if it doesn't already exist) and then activates
     * the component.
     */
    TooltipDirective.prototype.showTooltip = function () {
        var _this = this;
        return this.addTooltip().then(function (ref) {
            return ref.instance.renderTooltip(_this._el, {
                content: _this.tooltip,
                active: true,
                tooltipClass: _this.tooltipClass
            });
        });
    };
    /**
     * Deactivates the tooltip component if it exists.
     */
    TooltipDirective.prototype.hideTooltip = function () {
        if (this._tooltipRef) {
            this._tooltipRef.instance.renderTooltip(this._el, {
                content: this.tooltip,
                active: false,
                tooltipClass: this.tooltipClass
            });
        }
    };
    return TooltipDirective;
}());
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipDirective.prototype, "parentSelector", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TooltipDirective.prototype, "active", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipDirective.prototype, "tooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipDirective.prototype, "tooltipClass", void 0);
TooltipDirective = __decorate([
    Directive({
        selector: "[tooltip]",
        host: {
            "(mouseover)": "onMouseOver($event)",
            "(mouseleave)": "onMouseLeave($event)"
        }
    }),
    __param(3, Inject(DOCUMENT)),
    __metadata("design:paramtypes", [ComponentFactoryResolver,
        ViewContainerRef,
        ElementRef, Object])
], TooltipDirective);
export { TooltipDirective };
//# sourceMappingURL=tooltip.directive.js.map